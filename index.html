<script>
    // UPDATED: Fixed order base options, removed "其他"
    const baseIngredientOptions = [ "高筋麵粉", "中筋麵粉", "低筋麵粉", "全麥麵粉", "裸麥粉", "麵粉", "水", "牛奶", "糖", "鹽", "蜂蜜", "酵母", "泡打粉", "奶油", "鮮奶油", "奶油乳酪", "奶粉", "煉乳", "雞蛋", "優格", "酒", "香草精" ];
    // This will be populated by init()
    let ingredientOptions = [];
    
    // 食材含水率對照表 (預設值)
    let hydrationMap = { "水": 1.0, "煉乳": 0.3, "鮮奶油": 0.5, "優格": 0.9, "奶油乳酪": 0.5, "牛奶": 0.9, "雞蛋": 0.75, "蜂蜜": 0.17 };
    
    const groupOptions = [ "主麵團", "麵團餡料A", "麵團餡料B", "波蘭種", "液種", "中種", "魯班種", "內餡", "裝飾", "塔皮", "餅皮", "其他" ];
    const percentageGroups = [ "主麵團", "麵團餡料A", "麵團餡料B", "波蘭種", "液種", "中種", "魯班種" ];
    const flourCheckGroups = [ "主麵團", "波蘭種", "液種", "中種", "魯班種" ];

    let allRecipes = [];
    let editingTitle = null;
    let currentGroups = {};
    let lastUsedGroup = "主麵團";
    
    // 新增：智能換算工具相關變數
    let currentConversionRecipe = null;
    let conversionResults = null;
    
    // ====== 前端通知系統 ======
    function showNotification(message, type = 'success') {
      const notificationContainer = document.getElementById('notificationContainer');
      const notification = document.createElement('div');
      notification.className = `notification notification-${type}`;
      
      let icon = 'fa-check-circle';
      if (type === 'error') icon = 'fa-exclamation-circle';
      if (type === 'warning') icon = 'fa-exclamation-triangle';
      if (type === 'info') icon = 'fa-info-circle';
      
      notification.innerHTML = `
        <i class="fas ${icon} notification-icon"></i>
        <div class="notification-content">${message}</div>
        <button class="notification-close" onclick="this.parentElement.remove()">
          <i class="fas fa-times"></i>
        </button>
      `;
      
      notificationContainer.appendChild(notification);
      
      // 自動移除通知
      setTimeout(() => {
        if (notification.parentNode) {
          notification.remove();
        }
      }, 4000);
    }
    
    function showSaveProgress(show) {
        document.getElementById('saveProgress').style.display = show ? 'block' : 'none';
    }

    // ====== 應用程式初始化 (取代 google.script.run.getIngredientsDB()) ======
    async function init() {
        try {
            showNotification('正在載入自訂食材資料庫...', 'info');
            // 呼叫 Flask API 載入自訂食材資料庫
            const response = await fetch('/api/ingredients_db'); 
            
            if (!response.ok) {
                // 如果 HTTP 狀態碼不是 200-299 則拋出錯誤
                const errorData = await response.json();
                throw new Error(errorData.message || `伺服器回傳 ${response.status}`);
            }
            
            const customIngredients = await response.json(); // 假設 API 回傳 JSON 陣列

            // UPDATED: Construct the final ingredient list in the correct order
            const customIngredientNames = customIngredients.map(ing => ing.name);
            // Ensure no duplicates from base list
            const uniqueCustomNames = customIngredientNames.filter(name => !baseIngredientOptions.includes(name));
            ingredientOptions = [...baseIngredientOptions, ...uniqueCustomNames];

            // Update hydration map with custom and default values
            customIngredients.forEach(ing => {
              // 確保 ing.hydration 是數字
              const hydrationValue = parseFloat(ing.hydration) || 0; 
              hydrationMap[ing.name] = hydrationValue / 100;
            });
            
            // 初始化表單和食譜列表
            addIngredientRow();
            await loadRecipes(); // 載入食譜後會自動更新統計數據
            renderCustomIngredients(customIngredients);
            showNotification('初始化完成！', 'success');

        } catch (error) {
            console.error('初始化錯誤:', error);
            showNotification('初始化失敗: 無法載入自訂食材資料庫 (' + error.message + ')', 'error');
        }
    }
    
    // ====== 食譜載入 (取代 google.script.run.getRecipes()) ======
    async function loadRecipes() {
        try {
            showNotification('正在載入食譜列表...', 'info');
            const response = await fetch('/api/recipes');
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || `伺服器回傳 ${response.status}`);
            }
            const recipes = await response.json();
            
            allRecipes = recipes; // 更新全域變數
            renderRecipes(recipes); // 呼叫原本的渲染函數
            updateRecipeFilterOptions(recipes);
            updateStats(); // 更新統計資訊
            
            showNotification('食譜列表載入完成！', 'success');
        } catch (error) {
            console.error('載入食譜列表錯誤:', error);
            showNotification('載入食譜列表失敗: ' + error.message, 'error');
        }
    }

    // ====== 食譜儲存 (取代 google.script.run.saveRecipeToSheet()) ======
    async function saveRecipe() {
        const title = document.getElementById('title').value.trim();
        if (!title) {
            showNotification("食譜名稱不能為空。", 'warning');
            return;
        }

        const ingredients = collectIngredients();
        const steps = document.getElementById('steps').value;
        const topHeat = document.getElementById('top-heat').value;
        const bottomHeat = document.getElementById('bottom-heat').value;
        const bakingTime = document.getElementById('baking-time').value;
        const convection = document.getElementById('convection').checked ? '是' : '否';
        const steam = document.getElementById('steam').checked ? '是' : '否';

        // 檢查是否所有麵粉檢查組都有麵粉
        const missingFlourGroup = flourCheckGroups.find(group => {
            const groupIngredients = ingredients.filter(ing => ing.group === group);
            return groupIngredients.length > 0 && !groupIngredients.some(ing => isFlour(ing.name));
        });
        
        if (missingFlourGroup) {
            showNotification(`分組 **${missingFlourGroup}** 啟用了麵粉檢查，但缺少麵粉食材。請檢查。`, 'warning');
            return;
        }

        const recipeData = {
            title: title,
            ingredients: ingredients,
            steps: steps,
            top_heat: parseInt(topHeat),
            bottom_heat: parseInt(bottomHeat),
            baking_time: parseInt(bakingTime),
            convection: convection,
            steam: steam
        };

        showSaveProgress(true);
        try {
            const method = editingTitle ? 'PUT' : 'POST';
            const url = editingTitle 
                ? `/api/recipe?title=${encodeURIComponent(editingTitle)}` 
                : '/api/recipe';
            
            const response = await fetch(url, {
                method: method,
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(recipeData)
            });
            
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || `伺服器回傳 ${response.status}`);
            }
            
            const result = await response.json(); // 假設成功回傳 { status: 'success', ... }
            saveSuccessHandler(result);
            
        } catch (error) {
            saveFailureHandler(error);
        } finally {
            showSaveProgress(false);
        }
    }

    function saveSuccessHandler(result) {
        showNotification(`食譜 **${result.title}** ${editingTitle ? '更新' : '新增'}成功！`, 'success');
        resetForm();
        loadRecipes();
    }

    function saveFailureHandler(error) {
        console.error('儲存失敗:', error);
        showNotification('儲存食譜失敗: ' + error.message, 'error');
    }

    // ====== 食譜載入編輯 (取代 google.script.run.getRecipeByTitle()) ======
    async function loadRecipe(title) {
        try {
            showNotification(`正在載入 **${title}** 進行編輯...`, 'info');
            const response = await fetch(`/api/recipe?title=${encodeURIComponent(title)}`);
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || `伺服器回傳 ${response.status}`);
            }
            const recipe = await response.json();
            updateRecipeForm(recipe);
            showNotification('食譜載入完成，請開始編輯。', 'success');
            
        } catch (error) {
            console.error('載入食譜錯誤:', error);
            showNotification('載入食譜失敗: ' + error.message, 'error');
        }
    }

    // ====== 食譜刪除 (取代 google.script.run.deleteRecipeByTitle()) ======
    async function deleteRecipe(title) {
        if (confirm(`確定要刪除食譜：${title} 嗎？`)) {
            try {
                showNotification(`正在刪除食譜 **${title}**...`, 'warning');
                const response = await fetch(`/api/recipe?title=${encodeURIComponent(title)}`, {
                    method: 'DELETE'
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || `伺服器回傳 ${response.status}`);
                }
                
                // 假設成功刪除回傳 { status: 'success', title: '...' }
                deleteSuccessHandler({ status: 'success', title: title });
                
            } catch (error) {
                deleteFailureHandler(error);
            }
        }
    }
    
    function deleteSuccessHandler(result) {
        showNotification(`食譜 **${result.title}** 刪除成功！`, 'success');
        loadRecipes();
    }

    function deleteFailureHandler(error) {
        console.error('刪除失敗:', error);
        showNotification('刪除食譜失敗: ' + error.message, 'error');
    }

    // ====== 自訂食材儲存 (取代 google.script.run.saveIngredientDB()) ======
    async function saveCustomIngredient() {
        const name = document.getElementById('custom-ingredient-name').value.trim();
        const hydration = document.getElementById('custom-ingredient-hydration').value.trim();

        if (!name || !hydration || isNaN(parseFloat(hydration))) {
            showNotification("請輸入有效的食材名稱和含水率（數字）。", 'warning');
            return;
        }

        if (parseFloat(hydration) < 0 || parseFloat(hydration) > 100) {
            showNotification("含水率應在 0 到 100 之間。", 'warning');
            return;
        }

        try {
            const payload = { 
                name: name, 
                hydration: parseFloat(hydration) 
            };
            
            const response = await fetch('/api/ingredients_db', {
                method: 'POST', // Flask API 處理 POST (新增或更新)
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || `伺服器回傳 ${response.status}`);
            }
            
            const result = await response.json(); // 假設回傳 { status: 'success', ingredients_db: [...] }
            saveCustomIngredientSuccess(result.ingredients_db);
            
        } catch (error) {
            saveCustomIngredientFailure(error);
        }
    }

    function saveCustomIngredientSuccess(customIngredients) {
        showNotification('自訂食材資料庫更新成功！', 'success');
        document.getElementById('custom-ingredient-name').value = '';
        document.getElementById('custom-ingredient-hydration').value = '';
        
        // 重新初始化前端數據
        const customIngredientNames = customIngredients.map(ing => ing.name);
        const uniqueCustomNames = customIngredientNames.filter(name => !baseIngredientOptions.includes(name));
        ingredientOptions = [...baseIngredientOptions, ...uniqueCustomNames];
        customIngredients.forEach(ing => {
            hydrationMap[ing.name] = parseFloat(ing.hydration) / 100 || 0;
        });
        
        renderCustomIngredients(customIngredients);
        // 如果當前在食譜編輯頁，需要更新下拉選單
        updateIngredientSelects();
    }

    function saveCustomIngredientFailure(error) {
        console.error('自訂食材儲存失敗:', error);
        showNotification('儲存自訂食材失敗: ' + error.message, 'error');
    }

    // ====== 自訂食材刪除 (取代 google.script.run.deleteIngredientDB()) ======
    async function deleteCustomIngredient(name) {
        if (confirm(`確定要刪除自訂食材：${name} 嗎？此操作不可逆。`)) {
            try {
                showNotification(`正在刪除自訂食材 **${name}**...`, 'warning');
                const response = await fetch(`/api/ingredients_db?name=${encodeURIComponent(name)}`, {
                    method: 'DELETE'
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || `伺服器回傳 ${response.status}`);
                }
                
                const result = await response.json();
                deleteCustomIngredientSuccess(result.ingredients_db);

            } catch (error) {
                showNotification('刪除食材失敗: ' + error.message, 'error');
            }
        }
    }

    function deleteCustomIngredientSuccess(customIngredients) {
        showNotification('自訂食材刪除成功！', 'success');
        
        // 重新初始化前端數據
        const customIngredientNames = customIngredients.map(ing => ing.name);
        const uniqueCustomNames = customIngredientNames.filter(name => !baseIngredientOptions.includes(name));
        ingredientOptions = [...baseIngredientOptions, ...uniqueCustomNames];
        customIngredients.forEach(ing => {
            hydrationMap[ing.name] = parseFloat(ing.hydration) / 100 || 0;
        });

        renderCustomIngredients(customIngredients);
        updateIngredientSelects();
    }
    
    // ====== 智能換算計算 (取代 google.script.run.calculateConvertedIngredients()) ======
    async function calculateConversion() {
        if (!currentConversionRecipe) {
            showNotification('請先在管理頁面選擇或開始編輯一個食譜。', 'warning');
            return;
        }

        const newFlourEl = document.getElementById('newFlour');
        const newFlour = parseFloat(newFlourEl.value);
        const originalFlour = parseFloat(document.getElementById('originalFlour').value);
        const includeNonPercentage = document.getElementById('includeNonPercentage').checked;

        if (newFlour <= 0 || originalFlour <= 0) {
            showNotification('新的麵粉量必須大於 0。', 'warning');
            return;
        }

        const conversionData = {
            recipe: currentConversionRecipe,
            new_flour: newFlour,
            include_non_percentage: includeNonPercentage
        };
        
        try {
            showNotification('正在計算換算結果...', 'info');
            const response = await fetch('/api/convert', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(conversionData)
            });
            
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || `伺服器回傳 ${response.status}`);
            }
            
            const result = await response.json();
            renderConversionResults(result);
            
        } catch (error) {
            console.error('換算計算錯誤:', error);
            showNotification('換算計算失敗: ' + error.message, 'error');
        }
    }

    // ====== 保持所有客戶端邏輯 (DOM 操作、計算等) 不變 ======

    function updateStats() {
      document.getElementById('total-recipes').textContent = allRecipes.length;
      let totalIngredients = 0, totalWeight = 0, latestRecipe = null;
      allRecipes.forEach(recipe => {
        totalIngredients += recipe.ingredients.length;
        recipe.ingredients.forEach(ing => {
          // 僅計算百分比分組的總重量
          if (percentageGroups.includes(ing.group)) totalWeight += parseFloat(ing.weight) || 0;
        });
        if (!latestRecipe || new Date(recipe.timestamp) > new Date(latestRecipe.timestamp)) latestRecipe = recipe;
      });
      document.getElementById('total-ingredients').textContent = totalIngredients;
      document.getElementById('avg-weight').textContent = allRecipes.length ? (totalWeight / allRecipes.length).toFixed(0) : 0;
      document.getElementById('latest-recipe').textContent = latestRecipe ? latestRecipe.title : '-';
    }

    function switchTab(tabName) {
      document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
      document.querySelector(`.tab[onclick="switchTab('${tabName}')"]`).classList.add('active');
      document.getElementById(`${tabName}Tab`).classList.add('active');
      
      if (tabName === 'browse') {
        window.scrollTo(0, 0);
      }
      
      if (tabName === 'manage') {
        updateConversionToolButton();
      }
    }

    function addNewGroup() {
      const groupName = prompt("請輸入新分組名稱：");
      if (groupName && groupName.trim() !== "") {
        if (!groupOptions.includes(groupName)) groupOptions.push(groupName);
        addIngredientRow("", "", "", "", groupName);
        showNotification(`已新增分組: ${groupName}`, 'success');
      }
    }

    function isFlour(name) {
      if (!name) return false;
      const flourKeywords = [ "高筋麵粉", "中筋麵粉", "低筋麵粉", "全麥麵粉", "裸麥粉", "麵粉" ];
      return flourKeywords.some(keyword => name === keyword);
    }
    
    function isFlourIngredient(name) {
      return isFlour(name);
    }

    function calcHydration() {
      const rows = document.querySelectorAll(".ingredient-grid");
      let totalFlour = 0, totalWater = 0;
      rows.forEach(row => {
        const group = row.children[0].value;
        if (!percentageGroups.includes(group)) return;
        const foodName = row.children[1].value;
        const weight = parseFloat(row.children[2].value) || 0;
        
        if (isFlour(foodName)) totalFlour += weight;
        
        const factor = hydrationMap[foodName] !== undefined ? hydrationMap[foodName] : 0;
        totalWater += weight * factor;
      });
      
      const hydration = totalFlour > 0 ? (totalWater / totalFlour * 100).toFixed(1) : 0;
      const displayEl = document.getElementById("hydration-display");
      if (displayEl) displayEl.textContent = `含水率: ${hydration}%`;
    }

    function collectIngredients() {
      const rows = document.querySelectorAll(".ingredient-grid");
      const ingredients = [];
      rows.forEach(row => {
        const group = row.children[0].value;
        const name = row.children[1].value;
        const weight = row.children[2].value;
        const desc = row.children[4].value; // 說明欄位
        
        // 只有重量大於0的才儲存
        if (name && parseFloat(weight) > 0) {
          ingredients.push({
            group: group,
            name: name,
            weight: parseFloat(weight).toFixed(2),
            percentage: row.children[3].textContent.replace('%', ''),
            description: desc
          });
        }
      });
      return ingredients;
    }

    // [保留所有其他未修改的客戶端函數：]
    // renderCustomIngredients, updateIngredientSelects, addIngredientRow, removeIngredientRow,
    // updateGroupHeaders, removeGroup, calcPercentages, updateRecipeForm,
    // resetForm, renderRecipes, renderRecipeCard, updateRecipeFilterOptions,
    // filterByRecipe, filterRecipes, applySort, exportExcel, openConversionModal,
    // closeConversionModal, updateConversionToolButton, renderConversionResults,
    // copyConversionResults, applyConversionToForm, etc...

    function addIngredientRow(nameVal = "", weightVal = "", percentVal = "", descVal = "", groupVal = lastUsedGroup) {
      const container = document.getElementById("ingredients-container");
      
      // 檢查並新增分組標頭
      if (!currentGroups[groupVal]) {
        currentGroups[groupVal] = true;
        const groupHeader = document.createElement("div");
        groupHeader.className = "ingredient-group-header";
        groupHeader.innerHTML = `<span>${groupVal} 分組</span><span class="flour-warning" id="warning-${groupVal.replace(/\s+/g, '-')}"><i class="fas fa-exclamation-circle"></i> 此分組需要至少一種麵粉食材</span>`;
        container.appendChild(groupHeader);
        // 僅對需要檢查麵粉的分組顯示警告
        document.getElementById(`warning-${groupVal.replace(/\s+/g, "-")}`).style.display = flourCheckGroups.includes(groupVal) ? "block" : "none";
      }

      const row = document.createElement("div");
      row.className = "ingredient-grid";

      // 1. 分組 (Select)
      const groupSelect = document.createElement("select");
      groupSelect.innerHTML = groupOptions.map(g => `<option value="${g}" ${g === groupVal ? "selected" : ""}>${g}</option>`).join("");
      groupSelect.addEventListener("change", function() {
        lastUsedGroup = this.value;
        updateGroupHeaders();
        calcPercentages();
        calcHydration();
      });

      // 2. 食材名稱 (Select)
      const nameSelect = document.createElement("select");
      nameSelect.innerHTML = "<option value=''>選擇食材</option>" + ingredientOptions.map(o => `<option value="${o}">${o}</option>`).join("");
      if (nameVal) nameSelect.value = nameVal; // Directly set value
      nameSelect.addEventListener("change", function() {
        calcPercentages();
        calcHydration();
      });

      // 3. 重量 (Input Number)
      const weightInput = document.createElement("input");
      weightInput.type = "number";
      weightInput.placeholder = "重量 (g)";
      weightInput.min = "0";
      weightInput.step = "1";
      if (weightVal !== "" && weightVal !== undefined) weightInput.value = weightVal;
      weightInput.addEventListener("input", function() {
        // 限制為兩位小數
        this.value = parseFloat(this.value).toFixed(2);
        calcPercentages();
        calcHydration();
      });
      // 4. 百分比 (Span) - 顯示計算結果
      const percentSpan = document.createElement("span");
      percentSpan.className = "percentage-display";
      percentSpan.textContent = percentVal;
      
      // 5. 說明 (Input Text)
      const descInput = document.createElement("input");
      descInput.type = "text";
      descInput.placeholder = "說明 (可選)";
      if (descVal !== "" && descVal !== undefined) descInput.value = descVal;
      
      // 6. 刪除按鈕
      const deleteBtn = document.createElement("button");
      deleteBtn.className = "btn btn-danger btn-sm";
      deleteBtn.innerHTML = '<i class="fas fa-minus"></i>';
      deleteBtn.type = "button";
      deleteBtn.onclick = function() { removeIngredientRow(row); };
      
      row.appendChild(groupSelect);
      row.appendChild(nameSelect);
      row.appendChild(weightInput);
      row.appendChild(percentSpan);
      row.appendChild(descInput);
      row.appendChild(deleteBtn);
      
      // 添加到對應分組標頭之後
      const groupHeader = document.querySelector(`#ingredients-container .ingredient-group-header:last-of-type`);
      if (groupHeader) {
          groupHeader.insertAdjacentElement('afterend', row);
      } else {
          container.appendChild(row);
      }
      
      calcPercentages();
      calcHydration();
      updateConversionToolButton();
    }
    
    function removeIngredientRow(row) {
        if (confirm("確定要移除此食材嗎？")) {
            row.remove();
            calcPercentages();
            calcHydration();
            updateGroupHeaders();
            updateConversionToolButton();
        }
    }

    function removeGroup(groupName) {
        if (confirm(`確定要移除所有屬於 "${groupName}" 分組的食材嗎？`)) {
            const rows = document.querySelectorAll(".ingredient-grid");
            rows.forEach(row => {
                if (row.children[0].value === groupName) {
                    row.remove();
                }
            });
            calcPercentages();
            calcHydration();
            updateGroupHeaders(); // 清理空的分組標頭
            showNotification(`已移除分組: ${groupName} 的所有食材`, 'success');
            updateConversionToolButton();
        }
    }

    function updateGroupHeaders() {
        const rows = document.querySelectorAll(".ingredient-grid");
        const activeGroups = new Set();
        rows.forEach(row => activeGroups.add(row.children[0].value));

        // 清理無效的標頭和警告
        document.querySelectorAll(".ingredient-group-header").forEach(header => {
            const groupName = header.textContent.replace(' 分組', '').trim();
            if (!activeGroups.has(groupName)) {
                header.remove();
            } else {
                // 檢查是否包含麵粉並更新警告
                const hasFlour = Array.from(rows).some(row => 
                    row.children[0].value === groupName && isFlour(row.children[1].value)
                );
                
                const warningEl = document.getElementById(`warning-${groupName.replace(/\s+/g, '-')}`);
                if (warningEl) {
                    // 只有麵粉檢查組且沒有麵粉時顯示警告
                    warningEl.style.display = (flourCheckGroups.includes(groupName) && !hasFlour) ? "block" : "none";
                }
            }
        });

        // 重新構建 currentGroups 以反映當前狀態
        currentGroups = {};
        activeGroups.forEach(g => currentGroups[g] = true);
    }
    
    function calcPercentages() {
        const rows = document.querySelectorAll(".ingredient-grid");
        const groupTotals = {};
        const groupFlours = {};

        // 1. 計算總麵粉量和分組總重量
        rows.forEach(row => {
            const group = row.children[0].value;
            const name = row.children[1].value;
            const weight = parseFloat(row.children[2].value) || 0;

            if (percentageGroups.includes(group)) {
                if (!groupFlours[group]) groupFlours[group] = 0;
                if (!groupTotals[group]) groupTotals[group] = 0;
                
                groupTotals[group] += weight;
                if (isFlour(name)) {
                    groupFlours[group] += weight;
                }
            }
        });

        // 2. 計算並顯示百分比
        rows.forEach(row => {
            const group = row.children[0].value;
            const weight = parseFloat(row.children[2].value) || 0;
            const percentSpan = row.children[3];
            
            percentSpan.textContent = ""; // 清空

            if (percentageGroups.includes(group)) {
                const totalFlour = groupFlours[group];
                
                if (totalFlour > 0) {
                    const percentage = (weight / totalFlour * 100).toFixed(2);
                    percentSpan.textContent = `${percentage}%`;
                } else if (groupTotals[group] > 0) {
                    // 如果分組有重量但沒有麵粉 (如麵團餡料A/B 或錯誤的波蘭種)，則使用分組總重計算百分比
                    // 為了避免分母為0，且保留Apps Script中允許麵團餡料A/B無麵粉但仍計算百分比的邏輯
                    if (flourCheckGroups.includes(group)) {
                        percentSpan.textContent = "0.00%"; // 如果是麵粉檢查組，但沒有麵粉，強制為0
                    } else {
                        // 對於麵團餡料 A/B，以總重來計算百分比 (這是原Apps Script的邏輯)
                        // 注意：這在嚴謹的烘焙百分比中可能不是標準做法，但為了相容性保留此邏輯。
                        percentSpan.textContent = `0.00%`; 
                    }
                }
            }
        });
        
        updateGroupHeaders(); // 重新檢查麵粉警告
        updateConversionToolButton();
    }
    
    function updateRecipeForm(recipe) {
        resetForm(); // 先清除舊資料
        
        editingTitle = recipe.title;
        document.getElementById('title').value = recipe.title;
        document.getElementById('saveBtn').innerHTML = '<i class="fas fa-save"></i> 更新食譜';
        
        document.getElementById('steps').value = recipe.steps || '';
        document.getElementById('top-heat').value = recipe.top_heat || 200;
        document.getElementById('bottom-heat').value = recipe.bottom_heat || 200;
        document.getElementById('baking-time').value = recipe.baking_time || 30;
        document.getElementById('convection').checked = recipe.convection === '是';
        document.getElementById('steam').checked = recipe.steam === '是';

        // 載入食材
        recipe.ingredients.forEach(ing => {
            addIngredientRow(
                ing.name, 
                ing.weight, 
                `${ing.percentage}%`, 
                ing.description, 
                ing.group
            );
        });
        
        // 重新計算，確保所有百分比和含水率正確顯示
        calcPercentages();
        calcHydration();
        
        // 更新換算工具的食譜數據
        currentConversionRecipe = recipe;
        updateConversionToolButton();
        
        switchTab('manage');
    }

    function resetForm() {
        document.getElementById('title').value = '';
        document.getElementById('steps').value = '';
        document.getElementById('top-heat').value = 200;
        document.getElementById('bottom-heat').value = 200;
        document.getElementById('baking-time').value = 30;
        document.getElementById('convection').checked = false;
        document.getElementById('steam').checked = false;
        
        document.getElementById('ingredients-container').innerHTML = '';
        currentGroups = {};
        lastUsedGroup = "主麵團";
        addIngredientRow(); // 重新添加一個空的起始行
        
        editingTitle = null;
        document.getElementById('saveBtn').innerHTML = '<i class="fas fa-save"></i> 儲存食譜';
        document.getElementById("hydration-display").textContent = "含水率: 0%";
        
        // 清理換算工具數據
        currentConversionRecipe = null;
        document.getElementById('conversionResults').style.display = 'none';
        updateConversionToolButton();
    }

    function renderRecipes(recipes) {
      const listEl = document.getElementById('recipes-list');
      listEl.innerHTML = '';
      
      if (recipes.length === 0) {
        listEl.innerHTML = '<div class="empty-state"><i class="fas fa-box-open"></i><h3>沒有食譜資料</h3><p>請前往「食譜管理」新增食譜。</p></div>';
        return;
      }

      recipes.forEach(recipe => {
        listEl.appendChild(renderRecipeCard(recipe));
      });
      // 在渲染後立即應用當前篩選和排序
      filterRecipes();
    }
    
    function renderRecipeCard(recipe) {
      const card = document.createElement('div');
      card.className = 'recipe-card';
      
      const ingredientsHtml = recipe.ingredients.reduce((acc, ing) => {
        if (!acc.currentGroup || acc.currentGroup !== ing.group) {
          acc.html += `<tr class="ingredient-group-row"><td colspan="5">${ing.group} 分組</td></tr>`;
          acc.currentGroup = ing.group;
        }
        
        const isPercentage = percentageGroups.includes(ing.group);
        const percentage = isPercentage ? `<span class="group-badge">${ing.percentage}%</span>` : '';
        const weightDisplay = parseFloat(ing.weight).toFixed(2);
        
        acc.html += `
          <tr>
            <td>${ing.name}</td>
            <td>${weightDisplay} g</td>
            <td>${percentage}</td>
            <td>${ing.description || '-'}</td>
          </tr>
        `;
        return acc;
      }, { html: '', currentGroup: null }).html;
      
      const bakingDetails = `
        <div class="baking-container">
          <h4><i class="fas fa-thermometer-half"></i> 烘烤設定</h4>
          <p><strong>上火:</strong> ${recipe.top_heat || '-'}°C, <strong>下火:</strong> ${recipe.bottom_heat || '-'}°C, <strong>時間:</strong> ${recipe.baking_time || '-'} 分鐘</p>
          <p><strong>選項:</strong> ${recipe.convection === '是' ? '<span class="group-badge">旋風</span>' : ''} ${recipe.steam === '是' ? '<span class="group-badge">蒸汽</span>' : ''}</p>
        </div>
      `;

      card.innerHTML = `
        <div class="recipe-header">
          <div>
            <h3 class="recipe-title">${recipe.title}</h3>
            <p class="recipe-meta">建立時間: ${new Date(recipe.timestamp).toLocaleString()}</p>
          </div>
          <div class="action-buttons">
            <button class="btn btn-sm btn-warning" onclick="loadRecipe('${recipe.title.replace(/'/g, "\\'")}')"><i class="fas fa-edit"></i> 編輯</button>
            <button class="btn btn-sm btn-danger" onclick="deleteRecipe('${recipe.title.replace(/'/g, "\\'")}')"><i class="fas fa-trash-alt"></i> 刪除</button>
          </div>
        </div>

        <h4><i class="fas fa-cubes"></i> 食材 (${parseFloat(recipe.ingredients.reduce((sum, ing) => sum + (parseFloat(ing.weight) || 0), 0)).toFixed(2)} g 總重)</h4>
        <table class="ingredient-table">
          <thead>
            <tr>
              <th>食材名稱</th>
              <th>重量</th>
              <th>百分比</th>
              <th>說明</th>
            </tr>
          </thead>
          <tbody>${ingredientsHtml}</tbody>
        </table>

        <h4><i class="fas fa-info-circle"></i> 資訊</h4>
        ${bakingDetails}
        
        <div class="steps-container">
          <h4><i class="fas fa-list-ol"></i> 製作步驟</h4>
          <p>${recipe.steps ? recipe.steps.replace(/\n/g, '<br>') : '無步驟說明'}</p>
        </div>
      `;
      
      return card;
    }

    function updateRecipeFilterOptions(recipes) {
        const filterSelect = document.getElementById('recipeFilter');
        filterSelect.innerHTML = '<option value="">全部食譜</option>';
        const titles = [...new Set(recipes.map(r => r.title))].sort();
        titles.forEach(title => {
            const option = document.createElement('option');
            option.value = title;
            option.textContent = title;
            filterSelect.appendChild(option);
        });
    }

    let currentSort = 'newest';
    let currentFilterRecipe = '';
    let currentSearchTerm = '';

    function filterByRecipe() {
        currentFilterRecipe = document.getElementById('recipeFilter').value;
        filterRecipes();
    }

    function filterRecipes() {
        currentSearchTerm = document.getElementById('searchBar').value.toLowerCase().trim();
        const listEl = document.getElementById('recipes-list');
        listEl.innerHTML = '';
        let filteredRecipes = [...allRecipes];

        // 1. 篩選 (Filter)
        filteredRecipes = filteredRecipes.filter(recipe => {
            const titleMatch = !currentFilterRecipe || recipe.title === currentFilterRecipe;
            
            if (!currentSearchTerm) return titleMatch;

            // 搜尋關鍵字匹配
            const searchMatch = 
                recipe.title.toLowerCase().includes(currentSearchTerm) ||
                recipe.steps.toLowerCase().includes(currentSearchTerm) ||
                recipe.ingredients.some(ing => ing.name.toLowerCase().includes(currentSearchTerm));
            
            return titleMatch && searchMatch;
        });

        // 2. 排序 (Sort)
        filteredRecipes.sort((a, b) => {
            if (currentSort === 'newest') return new Date(b.timestamp) - new Date(a.timestamp);
            if (currentSort === 'oldest') return new Date(a.timestamp) - new Date(b.timestamp);
            if (currentSort === 'az') return a.title.localeCompare(b.title);
            if (currentSort === 'za') return b.title.localeCompare(a.title);
            return 0;
        });
        
        // 3. 渲染
        if (filteredRecipes.length === 0) {
            listEl.innerHTML = '<div class="empty-state"><i class="fas fa-search-minus"></i><h3>找不到符合條件的食譜</h3><p>請嘗試修改篩選或搜尋條件。</p></div>';
            return;
        }

        filteredRecipes.forEach(recipe => {
            listEl.appendChild(renderRecipeCard(recipe));
        });
    }

    function applySort() {
        currentSort = document.getElementById('sortSelect').value;
        filterRecipes();
    }

    function exportExcel() {
        if (allRecipes.length === 0) {
            showNotification('目前沒有食譜數據可以匯出。', 'warning');
            return;
        }

        const data = [];
        data.push(["食譜名稱", "分組", "食材", "重量 (g)", "百分比", "說明", "步驟", "建立時間", "上火溫度", "下火溫度", "烘烤時間", "旋風", "蒸汽"]);

        allRecipes.forEach(recipe => {
            const commonFields = [
                recipe.steps || "", 
                new Date(recipe.timestamp).toLocaleString(), 
                recipe.top_heat || "", 
                recipe.bottom_heat || "", 
                recipe.baking_time || "", 
                recipe.convection || "否", 
                recipe.steam || "否"
            ];

            recipe.ingredients.forEach((ing, index) => {
                const row = [
                    recipe.title,
                    ing.group,
                    ing.name,
                    ing.weight,
                    ing.percentage,
                    ing.description || "",
                    // 只有第一個食材行需要步驟和烘烤資訊
                    ...(index === 0 ? commonFields : ["", "", "", "", "", "", ""])
                ];
                data.push(row);
            });
        });

        const ws = XLSX.utils.aoa_to_sheet(data);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "食譜數據");

        XLSX.writeFile(wb, "TENG食譜數據匯出.xlsx");
        showNotification("食譜數據已成功匯出為 Excel。", 'success');
    }

    function renderCustomIngredients(customIngredients) {
        const listEl = document.getElementById('custom-ingredients-list');
        listEl.innerHTML = '<h4>現有自訂食材:</h4>';
        
        if (customIngredients.length === 0) {
            listEl.innerHTML += '<p>目前沒有自訂食材。</p>';
            return;
        }

        const ul = document.createElement('ul');
        customIngredients.forEach(ing => {
            const li = document.createElement('li');
            li.innerHTML = `
                <div class="ingredient-info">
                    <strong>${ing.name}</strong> 
                    <span class="group-badge" style="background-color: var(--info);">含水率: ${ing.hydration}%</span>
                </div>
                <div class="ingredient-actions">
                    <button class="btn btn-sm btn-warning" onclick="editCustomIngredient('${ing.name.replace(/'/g, "\\'")}', '${ing.hydration}')">
                        <i class="fas fa-pen"></i> 編輯
                    </button>
                    <button class="btn btn-sm btn-danger" onclick="deleteCustomIngredient('${ing.name.replace(/'/g, "\\'")}')">
                        <i class="fas fa-trash"></i> 刪除
                    </button>
                </div>
            `;
            ul.appendChild(li);
        });
        listEl.appendChild(ul);
    }
    
    function editCustomIngredient(name, hydration) {
        document.getElementById('custom-ingredient-name').value = name;
        document.getElementById('custom-ingredient-hydration').value = hydration;
        document.getElementById('custom-ingredient-name').focus();
        showNotification(`已載入 **${name}** 進行編輯。`, 'info');
    }

    // ===== 智能換算工具相關函數 =====
    function openConversionModal() {
        if (!editingTitle) {
            showNotification('請先在管理頁面載入或開始編輯一個食譜。', 'warning');
            return;
        }

        // 重新收集表單數據作為當前換算食譜
        currentConversionRecipe = {
            title: document.getElementById('title').value,
            ingredients: collectIngredients()
        };

        const originalFlour = calculateTotalFlour(currentConversionRecipe.ingredients);
        
        if (originalFlour <= 0) {
            showNotification('當前食譜沒有麵粉食材或總麵粉量為 0，無法進行換算。', 'error');
            return;
        }

        document.getElementById('originalFlour').value = originalFlour.toFixed(2);
        document.getElementById('newFlour').value = originalFlour.toFixed(2);
        document.getElementById('conversionRatio').value = '1.000';
        document.getElementById('conversionResults').style.display = 'none';
        
        // 確保倍數按鈕在打開時 1x 是選中的
        document.querySelectorAll('.conversion-option-btn').forEach(b => b.classList.remove('active'));
        document.querySelector('.conversion-option-btn[data-ratio="1"]').classList.add('active');


        document.getElementById('conversionModal').classList.add('active');
    }

    function closeConversionModal() {
        document.getElementById('conversionModal').classList.remove('active');
    }

    function calculateTotalFlour(ingredients) {
        let totalFlour = 0;
        ingredients.forEach(ing => {
            if (isFlourIngredient(ing.name) && percentageGroups.includes(ing.group)) {
                totalFlour += parseFloat(ing.weight) || 0;
            }
        });
        return totalFlour;
    }
    
    function updateConversionToolButton() {
      // 只有在編輯模式下，且食譜中有麵粉時才顯示按鈕
      if (editingTitle) {
        const ingredients = collectIngredients();
        const totalFlour = calculateTotalFlour(ingredients);
        document.getElementById('conversionToolBtn').style.display = totalFlour > 0 ? 'flex' : 'none';
      } else {
        document.getElementById('conversionToolBtn').style.display = 'none';
      }
    }
    
    function renderConversionResults(result) {
        if (result.status === 'error') {
            showNotification(`換算錯誤: ${result.message}`, 'error');
            document.getElementById('conversionResults').style.display = 'none';
            return;
        }

        conversionResults = result.ingredients; // 儲存結果以供應用
        const container = document.getElementById('convertedIngredientsTable');
        container.innerHTML = '';
        
        const table = document.createElement('table');
        table.className = 'converted-ingredient-table';
        table.innerHTML = `
            <thead>
                <tr>
                    <th>分組</th>
                    <th>食材</th>
                    <th>原始重量 (g)</th>
                    <th>換算後重量 (g)</th>
                    <th>變化</th>
                </tr>
            </thead>
            <tbody></tbody>
        `;
        const tbody = table.querySelector('tbody');
        
        result.ingredients.forEach(ing => {
            const originalWeight = parseFloat(ing.weight_original).toFixed(2);
            const convertedWeight = parseFloat(ing.weight).toFixed(2);
            const diff = (convertedWeight - originalWeight).toFixed(2);
            
            let diffClass = '';
            if (diff > 0) diffClass = 'weight-increase';
            if (diff < 0) diffClass = 'weight-decrease';
            
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${ing.group}</td>
                <td>${ing.name}</td>
                <td>${originalWeight}</td>
                <td>${convertedWeight}</td>
                <td><span class="${diffClass}">(${diff > 0 ? '+' : ''}${diff})</span></td>
            `;
            tbody.appendChild(row);
        });
        
        container.appendChild(table);
        document.getElementById('conversionResults').style.display = 'block';
        showNotification(`換算完成！比例為 ${result.conversion_ratio.toFixed(3)}`, 'success');
    }

    function copyConversionResults() {
        if (!conversionResults) return;
        
        let text = `食譜換算結果 (比例: ${document.getElementById('conversionRatio').value})\n`;
        let currentGroup = '';

        conversionResults.forEach(ing => {
            if (ing.group !== currentGroup) {
                text += `\n-- ${ing.group} 分組 --\n`;
                currentGroup = ing.group;
            }
            text += `${ing.name}: ${parseFloat(ing.weight).toFixed(2)} g (${ing.percentage}%)\n`;
        });

        navigator.clipboard.writeText(text).then(() => {
            showNotification('換算結果已複製到剪貼簿。', 'success');
        }).catch(err => {
            console.error('複製失敗:', err);
            showNotification('複製失敗，請手動複製。', 'error');
        });
    }

    function applyConversionToForm() {
        if (!conversionResults) {
            showNotification('請先計算換算結果。', 'warning');
            return;
        }

        // 清空現有食材
        document.getElementById('ingredients-container').innerHTML = '';
        currentGroups = {};

        // 應用新的食材列表
        conversionResults.forEach(ing => {
            addIngredientRow(
                ing.name, 
                ing.weight, 
                `${ing.percentage}%`, 
                ing.description, 
                ing.group
            );
        });

        // 重新計算，確保所有百分比和含水率正確顯示
        calcPercentages();
        calcHydration();
        
        closeConversionModal();
        showNotification('換算後的食材已成功應用到編輯表單！', 'success');
    }

    // 修正：倍數按鈕點擊事件
    document.addEventListener('DOMContentLoaded', function() {
      // 為換算選項按鈕添加點擊事件
      document.querySelectorAll('.conversion-option-btn').forEach(btn => {
        btn.addEventListener('click', function() {
          document.querySelectorAll('.conversion-option-btn').forEach(b => b.classList.remove('active'));
          this.classList.add('active');
          
          const ratio = parseFloat(this.getAttribute('data-ratio'));
          const originalFlour = parseFloat(document.getElementById('originalFlour').value) || 0;
          
          if (originalFlour > 0) {
            const newFlour = originalFlour * ratio;
            document.getElementById('newFlour').value = newFlour.toFixed(2);
            document.getElementById('conversionRatio').value = ratio.toFixed(3);
          } else {
             document.getElementById('newFlour').value = '';
             document.getElementById('conversionRatio').value = ratio.toFixed(3);
          }
        });
      });
      
      // 新增：輸入框變化時取消選中的倍數按鈕並重新計算比例
      document.getElementById('newFlour').addEventListener('input', function() {
        document.querySelectorAll('.conversion-option-btn').forEach(b => b.classList.remove('active'));
        
        const originalFlour = parseFloat(document.getElementById('originalFlour').value) || 0;
        const newFlour = parseFloat(this.value) || 0;
        
        if (newFlour > 0 && originalFlour > 0) {
          const ratio = newFlour / originalFlour;
          document.getElementById('conversionRatio').value = ratio.toFixed(3);
        } else {
          document.getElementById('conversionRatio').value = '0.000';
        }
      });
    });

    // 啟動應用程式
    window.onload = init;
  </script>
